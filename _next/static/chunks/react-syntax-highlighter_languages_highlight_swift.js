(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["react-syntax-highlighter_languages_highlight_swift"],{

/***/ "./node_modules/highlight.js/lib/languages/swift.js":
/*!**********************************************************!*\
  !*** ./node_modules/highlight.js/lib/languages/swift.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n\n  return re.source;\n}\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\nfunction concat(...args) {\n  const joined = args.map((x) => source(x)).join(\"\");\n  return joined;\n}\n\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\nfunction either(...args) {\n  const joined = '(' + args.map((x) => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n\nconst keywordWrapper = keyword => concat(\n  /\\b/,\n  keyword,\n  /\\w$/.test(keyword) ? /\\b/ : /\\B/\n);\n\n// Keywords that require a leading dot.\nconst dotKeywords = [\n  'Protocol', // contextual\n  'Type' // contextual\n].map(keywordWrapper);\n\n// Keywords that may have a leading dot.\nconst optionalDotKeywords = [\n  'init',\n  'self'\n].map(keywordWrapper);\n\n// should register as keyword, not type\nconst keywordTypes = [\n  'Any',\n  'Self'\n];\n\n// Regular keywords and literals.\nconst keywords = [\n  // strings below will be fed into the regular `keywords` engine while regex\n  // will result in additional modes being created to scan for those keywords to\n  // avoid conflicts with other rules\n  'associatedtype',\n  /as\\?/, // operator\n  /as!/, // operator\n  'as', // operator\n  'break',\n  'case',\n  'catch',\n  'class',\n  'continue',\n  'convenience', // contextual\n  'default',\n  'defer',\n  'deinit',\n  'didSet', // contextual\n  'do',\n  'dynamic', // contextual\n  'else',\n  'enum',\n  'extension',\n  'fallthrough',\n  'fileprivate(set)',\n  'fileprivate',\n  'final', // contextual\n  'for',\n  'func',\n  'get', // contextual\n  'guard',\n  'if',\n  'import',\n  'indirect', // contextual\n  'infix', // contextual\n  /init\\?/,\n  /init!/,\n  'inout',\n  'internal(set)',\n  'internal',\n  'in',\n  'is', // operator\n  'lazy', // contextual\n  'let',\n  'mutating', // contextual\n  'nonmutating', // contextual\n  'open(set)', // contextual\n  'open', // contextual\n  'operator',\n  'optional', // contextual\n  'override', // contextual\n  'postfix', // contextual\n  'precedencegroup',\n  'prefix', // contextual\n  'private(set)',\n  'private',\n  'protocol',\n  'public(set)',\n  'public',\n  'repeat',\n  'required', // contextual\n  'rethrows',\n  'return',\n  'set', // contextual\n  'some', // contextual\n  'static',\n  'struct',\n  'subscript',\n  'super',\n  'switch',\n  'throws',\n  'throw',\n  /try\\?/, // operator\n  /try!/, // operator\n  'try', // operator\n  'typealias',\n  'unowned(safe)', // contextual\n  'unowned(unsafe)', // contextual\n  'unowned', // contextual\n  'var',\n  'weak', // contextual\n  'where',\n  'while',\n  'willSet' // contextual\n];\n\n// NOTE: Contextual keywords are reserved only in specific contexts.\n// Ideally, these should be matched using modes to avoid false positives.\n\n// TODO: Create a PRECEDENCE_GROUP mode to match the remaining contextual keywords:\n// assignment associativity higherThan left lowerThan none right\n// These aren't included in the list because they result in mostly false positives.\n\n// Literals.\nconst literals = [\n  'false',\n  'nil',\n  'true'\n];\n\n// Keywords that start with a number sign (#).\n// #available is handled separately.\nconst numberSignKeywords = [\n  '#colorLiteral',\n  '#column',\n  '#dsohandle',\n  '#else',\n  '#elseif',\n  '#endif',\n  '#error',\n  '#file',\n  '#fileID',\n  '#fileLiteral',\n  '#filePath',\n  '#function',\n  '#if',\n  '#imageLiteral',\n  '#keyPath',\n  '#line',\n  '#selector',\n  '#sourceLocation',\n  '#warn_unqualified_access',\n  '#warning'\n];\n\n// Global functions in the Standard Library.\nconst builtIns = [\n  'abs',\n  'all',\n  'any',\n  'assert',\n  'assertionFailure',\n  'debugPrint',\n  'dump',\n  'fatalError',\n  'getVaList',\n  'isKnownUniquelyReferenced',\n  'max',\n  'min',\n  'numericCast',\n  'pointwiseMax',\n  'pointwiseMin',\n  'precondition',\n  'preconditionFailure',\n  'print',\n  'readLine',\n  'repeatElement',\n  'sequence',\n  'stride',\n  'swap',\n  'swift_unboxFromSwiftValueWithType',\n  'transcode',\n  'type',\n  'unsafeBitCast',\n  'unsafeDowncast',\n  'withExtendedLifetime',\n  'withUnsafeMutablePointer',\n  'withUnsafePointer',\n  'withVaList',\n  'withoutActuallyEscaping',\n  'zip'\n];\n\n// Valid first characters for operators.\nconst operatorHead = either(\n  /[/=\\-+!*%<>&|^~?]/,\n  /[\\u00A1-\\u00A7]/,\n  /[\\u00A9\\u00AB]/,\n  /[\\u00AC\\u00AE]/,\n  /[\\u00B0\\u00B1]/,\n  /[\\u00B6\\u00BB\\u00BF\\u00D7\\u00F7]/,\n  /[\\u2016-\\u2017]/,\n  /[\\u2020-\\u2027]/,\n  /[\\u2030-\\u203E]/,\n  /[\\u2041-\\u2053]/,\n  /[\\u2055-\\u205E]/,\n  /[\\u2190-\\u23FF]/,\n  /[\\u2500-\\u2775]/,\n  /[\\u2794-\\u2BFF]/,\n  /[\\u2E00-\\u2E7F]/,\n  /[\\u3001-\\u3003]/,\n  /[\\u3008-\\u3020]/,\n  /[\\u3030]/\n);\n\n// Valid characters for operators.\nconst operatorCharacter = either(\n  operatorHead,\n  /[\\u0300-\\u036F]/,\n  /[\\u1DC0-\\u1DFF]/,\n  /[\\u20D0-\\u20FF]/,\n  /[\\uFE00-\\uFE0F]/,\n  /[\\uFE20-\\uFE2F]/\n  // TODO: The following characters are also allowed, but the regex isn't supported yet.\n  // /[\\u{E0100}-\\u{E01EF}]/u\n);\n\n// Valid operator.\nconst operator = concat(operatorHead, operatorCharacter, '*');\n\n// Valid first characters for identifiers.\nconst identifierHead = either(\n  /[a-zA-Z_]/,\n  /[\\u00A8\\u00AA\\u00AD\\u00AF\\u00B2-\\u00B5\\u00B7-\\u00BA]/,\n  /[\\u00BC-\\u00BE\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u00FF]/,\n  /[\\u0100-\\u02FF\\u0370-\\u167F\\u1681-\\u180D\\u180F-\\u1DBF]/,\n  /[\\u1E00-\\u1FFF]/,\n  /[\\u200B-\\u200D\\u202A-\\u202E\\u203F-\\u2040\\u2054\\u2060-\\u206F]/,\n  /[\\u2070-\\u20CF\\u2100-\\u218F\\u2460-\\u24FF\\u2776-\\u2793]/,\n  /[\\u2C00-\\u2DFF\\u2E80-\\u2FFF]/,\n  /[\\u3004-\\u3007\\u3021-\\u302F\\u3031-\\u303F\\u3040-\\uD7FF]/,\n  /[\\uF900-\\uFD3D\\uFD40-\\uFDCF\\uFDF0-\\uFE1F\\uFE30-\\uFE44]/,\n  /[\\uFE47-\\uFFFD]/\n  // The following characters are also allowed, but the regexes aren't supported yet.\n  // /[\\u{10000}-\\u{1FFFD}\\u{20000-\\u{2FFFD}\\u{30000}-\\u{3FFFD}\\u{40000}-\\u{4FFFD}]/u,\n  // /[\\u{50000}-\\u{5FFFD}\\u{60000-\\u{6FFFD}\\u{70000}-\\u{7FFFD}\\u{80000}-\\u{8FFFD}]/u,\n  // /[\\u{90000}-\\u{9FFFD}\\u{A0000-\\u{AFFFD}\\u{B0000}-\\u{BFFFD}\\u{C0000}-\\u{CFFFD}]/u,\n  // /[\\u{D0000}-\\u{DFFFD}\\u{E0000-\\u{EFFFD}]/u\n);\n\n// Valid characters for identifiers.\nconst identifierCharacter = either(\n  identifierHead,\n  /\\d/,\n  /[\\u0300-\\u036F\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]/\n);\n\n// Valid identifier.\nconst identifier = concat(identifierHead, identifierCharacter, '*');\n\n// Valid type identifier.\nconst typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*');\n\n// Built-in attributes, which are highlighted as keywords.\n// @available is handled separately.\nconst keywordAttributes = [\n  'autoclosure',\n  concat(/convention\\(/, either('swift', 'block', 'c'), /\\)/),\n  'discardableResult',\n  'dynamicCallable',\n  'dynamicMemberLookup',\n  'escaping',\n  'frozen',\n  'GKInspectable',\n  'IBAction',\n  'IBDesignable',\n  'IBInspectable',\n  'IBOutlet',\n  'IBSegueAction',\n  'inlinable',\n  'main',\n  'nonobjc',\n  'NSApplicationMain',\n  'NSCopying',\n  'NSManaged',\n  concat(/objc\\(/, identifier, /\\)/),\n  'objc',\n  'objcMembers',\n  'propertyWrapper',\n  'requires_stored_property_inits',\n  'testable',\n  'UIApplicationMain',\n  'unknown',\n  'usableFromInline'\n];\n\n// Contextual keywords used in @available and #available.\nconst availabilityKeywords = [\n  'iOS',\n  'iOSApplicationExtension',\n  'macOS',\n  'macOSApplicationExtension',\n  'macCatalyst',\n  'macCatalystApplicationExtension',\n  'watchOS',\n  'watchOSApplicationExtension',\n  'tvOS',\n  'tvOSApplicationExtension',\n  'swift'\n];\n\n/*\nLanguage: Swift\nDescription: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.\nAuthor: Steven Van Impe <steven.vanimpe@icloud.com>\nContributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>\nWebsite: https://swift.org\nCategory: common, system\n*/\n\n/** @type LanguageFn */\nfunction swift(hljs) {\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411\n  const BLOCK_COMMENT = hljs.COMMENT(\n    '/\\\\*',\n    '\\\\*/',\n    {\n      contains: [ 'self' ]\n    }\n  );\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413\n  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html\n  const DOT_KEYWORD = {\n    className: 'keyword',\n    begin: concat(/\\./, lookahead(either(...dotKeywords, ...optionalDotKeywords))),\n    end: either(...dotKeywords, ...optionalDotKeywords),\n    excludeBegin: true\n  };\n  const KEYWORD_GUARD = {\n    // Consume .keyword to prevent highlighting properties and methods as keywords.\n    begin: concat(/\\./, either(...keywords)),\n    relevance: 0\n  };\n  const PLAIN_KEYWORDS = keywords\n    .filter(kw => typeof kw === 'string')\n    .concat([ \"_|0\" ]); // seems common, so 0 relevance\n  const REGEX_KEYWORDS = keywords\n    .filter(kw => typeof kw !== 'string') // find regex\n    .concat(keywordTypes)\n    .map(keywordWrapper);\n  const KEYWORD = {\n    variants: [\n      {\n        className: 'keyword',\n        begin: either(...REGEX_KEYWORDS, ...optionalDotKeywords)\n      }\n    ]\n  };\n  // find all the regular keywords\n  const KEYWORDS = {\n    $pattern: either(\n      /\\b\\w+(\\(\\w+\\))?/, // kw or kw(arg)\n      /#\\w+/ // number keywords\n    ),\n    keyword: PLAIN_KEYWORDS\n      .concat(numberSignKeywords)\n      .join(\" \"),\n    literal: literals.join(\" \")\n  };\n  const KEYWORD_MODES = [\n    DOT_KEYWORD,\n    KEYWORD_GUARD,\n    KEYWORD\n  ];\n\n  // https://github.com/apple/swift/tree/main/stdlib/public/core\n  const BUILT_IN_GUARD = {\n    // Consume .built_in to prevent highlighting properties and methods.\n    begin: concat(/\\./, either(...builtIns)),\n    relevance: 0\n  };\n  const BUILT_IN = {\n    className: 'built_in',\n    begin: concat(/\\b/, either(...builtIns), /(?=\\()/)\n  };\n  const BUILT_INS = [\n    BUILT_IN_GUARD,\n    BUILT_IN\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418\n  const OPERATOR_GUARD = {\n    // Prevent -> from being highlighting as an operator.\n    begin: /->/,\n    relevance: 0\n  };\n  const OPERATOR = {\n    className: 'operator',\n    relevance: 0,\n    variants: [\n      {\n        begin: operator\n      },\n      {\n        // dot-operator: only operators that start with a dot are allowed to use dots as\n        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more\n        // characters that may also include dots.\n        begin: `\\\\.(\\\\.|${operatorCharacter})+`\n      }\n    ]\n  };\n  const OPERATORS = [\n    OPERATOR_GUARD,\n    OPERATOR\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal\n  // TODO: Update for leading `-` after lookbehind is supported everywhere\n  const decimalDigits = '([0-9]_*)+';\n  const hexDigits = '([0-9a-fA-F]_*)+';\n  const NUMBER = {\n    className: 'number',\n    relevance: 0,\n    variants: [\n      // decimal floating-point-literal (subsumes decimal-literal)\n      {\n        begin: `\\\\b(${decimalDigits})(\\\\.(${decimalDigits}))?` + `([eE][+-]?(${decimalDigits}))?\\\\b`\n      },\n      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)\n      {\n        begin: `\\\\b0x(${hexDigits})(\\\\.(${hexDigits}))?` + `([pP][+-]?(${decimalDigits}))?\\\\b`\n      },\n      // octal-literal\n      {\n        begin: /\\b0o([0-7]_*)+\\b/\n      },\n      // binary-literal\n      {\n        begin: /\\b0b([01]_*)+\\b/\n      }\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal\n  const ESCAPED_CHARACTER = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    variants: [\n      {\n        begin: concat(/\\\\/, rawDelimiter, /[0\\\\tnr\"']/)\n      },\n      {\n        begin: concat(/\\\\/, rawDelimiter, /u\\{[0-9a-fA-F]{1,8}\\}/)\n      }\n    ]\n  });\n  const ESCAPED_NEWLINE = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    begin: concat(/\\\\/, rawDelimiter, /[\\t ]*(?:[\\r\\n]|\\r\\n)/)\n  });\n  const INTERPOLATION = (rawDelimiter = \"\") => ({\n    className: 'subst',\n    label: \"interpol\",\n    begin: concat(/\\\\/, rawDelimiter, /\\(/),\n    end: /\\)/\n  });\n  const MULTILINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"\"\"/),\n    end: concat(/\"\"\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      ESCAPED_NEWLINE(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const SINGLE_LINE_STRING = (rawDelimiter = \"\") => ({\n    begin: concat(rawDelimiter, /\"/),\n    end: concat(/\"/, rawDelimiter),\n    contains: [\n      ESCAPED_CHARACTER(rawDelimiter),\n      INTERPOLATION(rawDelimiter)\n    ]\n  });\n  const STRING = {\n    className: 'string',\n    variants: [\n      MULTILINE_STRING(),\n      MULTILINE_STRING(\"#\"),\n      MULTILINE_STRING(\"##\"),\n      MULTILINE_STRING(\"###\"),\n      SINGLE_LINE_STRING(),\n      SINGLE_LINE_STRING(\"#\"),\n      SINGLE_LINE_STRING(\"##\"),\n      SINGLE_LINE_STRING(\"###\")\n    ]\n  };\n\n  // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412\n  const QUOTED_IDENTIFIER = {\n    begin: concat(/`/, identifier, /`/)\n  };\n  const IMPLICIT_PARAMETER = {\n    className: 'variable',\n    begin: /\\$\\d+/\n  };\n  const PROPERTY_WRAPPER_PROJECTION = {\n    className: 'variable',\n    begin: `\\\\$${identifierCharacter}+`\n  };\n  const IDENTIFIERS = [\n    QUOTED_IDENTIFIER,\n    IMPLICIT_PARAMETER,\n    PROPERTY_WRAPPER_PROJECTION\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html\n  const AVAILABLE_ATTRIBUTE = {\n    begin: /(@|#)available\\(/,\n    end: /\\)/,\n    keywords: {\n      $pattern: /[@#]?\\w+/,\n      keyword: availabilityKeywords\n        .concat([\n          \"@available\",\n          \"#available\"\n        ])\n        .join(' ')\n    },\n    contains: [\n      ...OPERATORS,\n      NUMBER,\n      STRING\n    ]\n  };\n  const KEYWORD_ATTRIBUTE = {\n    className: 'keyword',\n    begin: concat(/@/, either(...keywordAttributes))\n  };\n  const USER_DEFINED_ATTRIBUTE = {\n    className: 'meta',\n    begin: concat(/@/, identifier)\n  };\n  const ATTRIBUTES = [\n    AVAILABLE_ATTRIBUTE,\n    KEYWORD_ATTRIBUTE,\n    USER_DEFINED_ATTRIBUTE\n  ];\n\n  // https://docs.swift.org/swift-book/ReferenceManual/Types.html\n  const TYPE = {\n    begin: lookahead(/\\b[A-Z]/),\n    relevance: 0,\n    contains: [\n      { // Common Apple frameworks, for relevance boost\n        className: 'type',\n        begin: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')\n      },\n      { // Type identifier\n        className: 'type',\n        begin: typeIdentifier,\n        relevance: 0\n      },\n      { // Optional type\n        begin: /[?!]+/,\n        relevance: 0\n      },\n      { // Variadic parameter\n        begin: /\\.\\.\\./,\n        relevance: 0\n      },\n      { // Protocol composition\n        begin: concat(/\\s+&\\s+/, lookahead(typeIdentifier)),\n        relevance: 0\n      }\n    ]\n  };\n  const GENERIC_ARGUMENTS = {\n    begin: /</,\n    end: />/,\n    keywords: KEYWORDS,\n    contains: [\n      ...KEYWORD_MODES,\n      ...ATTRIBUTES,\n      OPERATOR_GUARD,\n      TYPE\n    ]\n  };\n  TYPE.contains.push(GENERIC_ARGUMENTS);\n\n  // Add supported submodes to string interpolation.\n  for (const variant of STRING.variants) {\n    const interpolation = variant.contains.find(mode => mode.label === \"interpol\");\n    // TODO: Interpolation can contain any expression, so there's room for improvement here.\n    interpolation.keywords = KEYWORDS;\n    const submodes = [\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS\n    ];\n    interpolation.contains = [\n      ...submodes,\n      {\n        begin: /\\(/,\n        end: /\\)/,\n        contains: [\n          'self',\n          ...submodes\n        ]\n      }\n    ];\n  }\n\n  return {\n    name: 'Swift',\n    keywords: KEYWORDS,\n    contains: [\n      hljs.C_LINE_COMMENT_MODE,\n      BLOCK_COMMENT,\n      {\n        className: 'function',\n        beginKeywords: 'func',\n        end: /\\{/,\n        excludeEnd: true,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, {\n            begin: /[A-Za-z$_][0-9A-Za-z$_]*/\n          }),\n          {\n            begin: /</,\n            end: />/\n          },\n          {\n            className: 'params',\n            begin: /\\(/,\n            end: /\\)/,\n            endsParent: true,\n            keywords: KEYWORDS,\n            contains: [\n              'self',\n              ...KEYWORD_MODES,\n              NUMBER,\n              STRING,\n              hljs.C_BLOCK_COMMENT_MODE,\n              { // relevance booster\n                begin: ':'\n              }\n            ],\n            illegal: /[\"']/\n          }\n        ],\n        illegal: /\\[|%/\n      },\n      {\n        className: 'class',\n        beginKeywords: 'struct protocol class extension enum',\n        end: '\\\\{',\n        excludeEnd: true,\n        keywords: KEYWORDS,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, {\n            begin: /[A-Za-z$_][\\u00C0-\\u02B80-9A-Za-z$_]*/\n          }),\n          ...KEYWORD_MODES\n        ]\n      },\n      {\n        beginKeywords: 'import',\n        end: /$/,\n        contains: [\n          hljs.C_LINE_COMMENT_MODE,\n          BLOCK_COMMENT\n        ],\n        relevance: 0\n      },\n      ...KEYWORD_MODES,\n      ...BUILT_INS,\n      ...OPERATORS,\n      NUMBER,\n      STRING,\n      ...IDENTIFIERS,\n      ...ATTRIBUTES,\n      TYPE\n    ]\n  };\n}\n\nmodule.exports = swift;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvbGFuZ3VhZ2VzL3N3aWZ0LmpzPzJhMzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOztBQUVBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE1BQU0sSUFBSSxNQUFNO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTSxJQUFJLE1BQU0sR0FBRyxTQUFTLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNO0FBQ2xGLFVBQVUsTUFBTSxJQUFJLE1BQU0sR0FBRyxTQUFTLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNO0FBQ2xGLFVBQVUsTUFBTSxJQUFJLE1BQU0sR0FBRyxTQUFTLE1BQU0sR0FBRyxNQUFNLElBQUksTUFBTSxHQUFHLE1BQU0sSUFBSSxNQUFNO0FBQ2xGLFVBQVUsTUFBTSxJQUFJLE1BQU0sR0FBRyxTQUFTLE1BQU07QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsUUFBUSxjQUFjLHFCQUFxQixjQUFjO0FBQzdGLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLFVBQVUsUUFBUSxVQUFVLHFCQUFxQixjQUFjO0FBQ3ZGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDhDQUE4QyxZQUFZLElBQUksRUFBRTtBQUNoRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9sYW5ndWFnZXMvc3dpZnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge1JlZ0V4cH1cbiAqICovXG5cbi8qKlxuICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmcgfSByZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc291cmNlKHJlKSB7XG4gIGlmICghcmUpIHJldHVybiBudWxsO1xuICBpZiAodHlwZW9mIHJlID09PSBcInN0cmluZ1wiKSByZXR1cm4gcmU7XG5cbiAgcmV0dXJuIHJlLnNvdXJjZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBsb29rYWhlYWQocmUpIHtcbiAgcmV0dXJuIGNvbmNhdCgnKD89JywgcmUsICcpJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsuLi4oUmVnRXhwIHwgc3RyaW5nKSB9IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCguLi5hcmdzKSB7XG4gIGNvbnN0IGpvaW5lZCA9IGFyZ3MubWFwKCh4KSA9PiBzb3VyY2UoeCkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cbi8qKlxuICogQW55IG9mIHRoZSBwYXNzZWQgZXhwcmVzc3Npb25zIG1heSBtYXRjaFxuICpcbiAqIENyZWF0ZXMgYSBodWdlIHRoaXMgfCB0aGlzIHwgdGhhdCB8IHRoYXQgbWF0Y2hcbiAqIEBwYXJhbSB7KFJlZ0V4cCB8IHN0cmluZylbXSB9IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVpdGhlciguLi5hcmdzKSB7XG4gIGNvbnN0IGpvaW5lZCA9ICcoJyArIGFyZ3MubWFwKCh4KSA9PiBzb3VyY2UoeCkpLmpvaW4oXCJ8XCIpICsgXCIpXCI7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cbmNvbnN0IGtleXdvcmRXcmFwcGVyID0ga2V5d29yZCA9PiBjb25jYXQoXG4gIC9cXGIvLFxuICBrZXl3b3JkLFxuICAvXFx3JC8udGVzdChrZXl3b3JkKSA/IC9cXGIvIDogL1xcQi9cbik7XG5cbi8vIEtleXdvcmRzIHRoYXQgcmVxdWlyZSBhIGxlYWRpbmcgZG90LlxuY29uc3QgZG90S2V5d29yZHMgPSBbXG4gICdQcm90b2NvbCcsIC8vIGNvbnRleHR1YWxcbiAgJ1R5cGUnIC8vIGNvbnRleHR1YWxcbl0ubWFwKGtleXdvcmRXcmFwcGVyKTtcblxuLy8gS2V5d29yZHMgdGhhdCBtYXkgaGF2ZSBhIGxlYWRpbmcgZG90LlxuY29uc3Qgb3B0aW9uYWxEb3RLZXl3b3JkcyA9IFtcbiAgJ2luaXQnLFxuICAnc2VsZidcbl0ubWFwKGtleXdvcmRXcmFwcGVyKTtcblxuLy8gc2hvdWxkIHJlZ2lzdGVyIGFzIGtleXdvcmQsIG5vdCB0eXBlXG5jb25zdCBrZXl3b3JkVHlwZXMgPSBbXG4gICdBbnknLFxuICAnU2VsZidcbl07XG5cbi8vIFJlZ3VsYXIga2V5d29yZHMgYW5kIGxpdGVyYWxzLlxuY29uc3Qga2V5d29yZHMgPSBbXG4gIC8vIHN0cmluZ3MgYmVsb3cgd2lsbCBiZSBmZWQgaW50byB0aGUgcmVndWxhciBga2V5d29yZHNgIGVuZ2luZSB3aGlsZSByZWdleFxuICAvLyB3aWxsIHJlc3VsdCBpbiBhZGRpdGlvbmFsIG1vZGVzIGJlaW5nIGNyZWF0ZWQgdG8gc2NhbiBmb3IgdGhvc2Uga2V5d29yZHMgdG9cbiAgLy8gYXZvaWQgY29uZmxpY3RzIHdpdGggb3RoZXIgcnVsZXNcbiAgJ2Fzc29jaWF0ZWR0eXBlJyxcbiAgL2FzXFw/LywgLy8gb3BlcmF0b3JcbiAgL2FzIS8sIC8vIG9wZXJhdG9yXG4gICdhcycsIC8vIG9wZXJhdG9yXG4gICdicmVhaycsXG4gICdjYXNlJyxcbiAgJ2NhdGNoJyxcbiAgJ2NsYXNzJyxcbiAgJ2NvbnRpbnVlJyxcbiAgJ2NvbnZlbmllbmNlJywgLy8gY29udGV4dHVhbFxuICAnZGVmYXVsdCcsXG4gICdkZWZlcicsXG4gICdkZWluaXQnLFxuICAnZGlkU2V0JywgLy8gY29udGV4dHVhbFxuICAnZG8nLFxuICAnZHluYW1pYycsIC8vIGNvbnRleHR1YWxcbiAgJ2Vsc2UnLFxuICAnZW51bScsXG4gICdleHRlbnNpb24nLFxuICAnZmFsbHRocm91Z2gnLFxuICAnZmlsZXByaXZhdGUoc2V0KScsXG4gICdmaWxlcHJpdmF0ZScsXG4gICdmaW5hbCcsIC8vIGNvbnRleHR1YWxcbiAgJ2ZvcicsXG4gICdmdW5jJyxcbiAgJ2dldCcsIC8vIGNvbnRleHR1YWxcbiAgJ2d1YXJkJyxcbiAgJ2lmJyxcbiAgJ2ltcG9ydCcsXG4gICdpbmRpcmVjdCcsIC8vIGNvbnRleHR1YWxcbiAgJ2luZml4JywgLy8gY29udGV4dHVhbFxuICAvaW5pdFxcPy8sXG4gIC9pbml0IS8sXG4gICdpbm91dCcsXG4gICdpbnRlcm5hbChzZXQpJyxcbiAgJ2ludGVybmFsJyxcbiAgJ2luJyxcbiAgJ2lzJywgLy8gb3BlcmF0b3JcbiAgJ2xhenknLCAvLyBjb250ZXh0dWFsXG4gICdsZXQnLFxuICAnbXV0YXRpbmcnLCAvLyBjb250ZXh0dWFsXG4gICdub25tdXRhdGluZycsIC8vIGNvbnRleHR1YWxcbiAgJ29wZW4oc2V0KScsIC8vIGNvbnRleHR1YWxcbiAgJ29wZW4nLCAvLyBjb250ZXh0dWFsXG4gICdvcGVyYXRvcicsXG4gICdvcHRpb25hbCcsIC8vIGNvbnRleHR1YWxcbiAgJ292ZXJyaWRlJywgLy8gY29udGV4dHVhbFxuICAncG9zdGZpeCcsIC8vIGNvbnRleHR1YWxcbiAgJ3ByZWNlZGVuY2Vncm91cCcsXG4gICdwcmVmaXgnLCAvLyBjb250ZXh0dWFsXG4gICdwcml2YXRlKHNldCknLFxuICAncHJpdmF0ZScsXG4gICdwcm90b2NvbCcsXG4gICdwdWJsaWMoc2V0KScsXG4gICdwdWJsaWMnLFxuICAncmVwZWF0JyxcbiAgJ3JlcXVpcmVkJywgLy8gY29udGV4dHVhbFxuICAncmV0aHJvd3MnLFxuICAncmV0dXJuJyxcbiAgJ3NldCcsIC8vIGNvbnRleHR1YWxcbiAgJ3NvbWUnLCAvLyBjb250ZXh0dWFsXG4gICdzdGF0aWMnLFxuICAnc3RydWN0JyxcbiAgJ3N1YnNjcmlwdCcsXG4gICdzdXBlcicsXG4gICdzd2l0Y2gnLFxuICAndGhyb3dzJyxcbiAgJ3Rocm93JyxcbiAgL3RyeVxcPy8sIC8vIG9wZXJhdG9yXG4gIC90cnkhLywgLy8gb3BlcmF0b3JcbiAgJ3RyeScsIC8vIG9wZXJhdG9yXG4gICd0eXBlYWxpYXMnLFxuICAndW5vd25lZChzYWZlKScsIC8vIGNvbnRleHR1YWxcbiAgJ3Vub3duZWQodW5zYWZlKScsIC8vIGNvbnRleHR1YWxcbiAgJ3Vub3duZWQnLCAvLyBjb250ZXh0dWFsXG4gICd2YXInLFxuICAnd2VhaycsIC8vIGNvbnRleHR1YWxcbiAgJ3doZXJlJyxcbiAgJ3doaWxlJyxcbiAgJ3dpbGxTZXQnIC8vIGNvbnRleHR1YWxcbl07XG5cbi8vIE5PVEU6IENvbnRleHR1YWwga2V5d29yZHMgYXJlIHJlc2VydmVkIG9ubHkgaW4gc3BlY2lmaWMgY29udGV4dHMuXG4vLyBJZGVhbGx5LCB0aGVzZSBzaG91bGQgYmUgbWF0Y2hlZCB1c2luZyBtb2RlcyB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMuXG5cbi8vIFRPRE86IENyZWF0ZSBhIFBSRUNFREVOQ0VfR1JPVVAgbW9kZSB0byBtYXRjaCB0aGUgcmVtYWluaW5nIGNvbnRleHR1YWwga2V5d29yZHM6XG4vLyBhc3NpZ25tZW50IGFzc29jaWF0aXZpdHkgaGlnaGVyVGhhbiBsZWZ0IGxvd2VyVGhhbiBub25lIHJpZ2h0XG4vLyBUaGVzZSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlIGxpc3QgYmVjYXVzZSB0aGV5IHJlc3VsdCBpbiBtb3N0bHkgZmFsc2UgcG9zaXRpdmVzLlxuXG4vLyBMaXRlcmFscy5cbmNvbnN0IGxpdGVyYWxzID0gW1xuICAnZmFsc2UnLFxuICAnbmlsJyxcbiAgJ3RydWUnXG5dO1xuXG4vLyBLZXl3b3JkcyB0aGF0IHN0YXJ0IHdpdGggYSBudW1iZXIgc2lnbiAoIykuXG4vLyAjYXZhaWxhYmxlIGlzIGhhbmRsZWQgc2VwYXJhdGVseS5cbmNvbnN0IG51bWJlclNpZ25LZXl3b3JkcyA9IFtcbiAgJyNjb2xvckxpdGVyYWwnLFxuICAnI2NvbHVtbicsXG4gICcjZHNvaGFuZGxlJyxcbiAgJyNlbHNlJyxcbiAgJyNlbHNlaWYnLFxuICAnI2VuZGlmJyxcbiAgJyNlcnJvcicsXG4gICcjZmlsZScsXG4gICcjZmlsZUlEJyxcbiAgJyNmaWxlTGl0ZXJhbCcsXG4gICcjZmlsZVBhdGgnLFxuICAnI2Z1bmN0aW9uJyxcbiAgJyNpZicsXG4gICcjaW1hZ2VMaXRlcmFsJyxcbiAgJyNrZXlQYXRoJyxcbiAgJyNsaW5lJyxcbiAgJyNzZWxlY3RvcicsXG4gICcjc291cmNlTG9jYXRpb24nLFxuICAnI3dhcm5fdW5xdWFsaWZpZWRfYWNjZXNzJyxcbiAgJyN3YXJuaW5nJ1xuXTtcblxuLy8gR2xvYmFsIGZ1bmN0aW9ucyBpbiB0aGUgU3RhbmRhcmQgTGlicmFyeS5cbmNvbnN0IGJ1aWx0SW5zID0gW1xuICAnYWJzJyxcbiAgJ2FsbCcsXG4gICdhbnknLFxuICAnYXNzZXJ0JyxcbiAgJ2Fzc2VydGlvbkZhaWx1cmUnLFxuICAnZGVidWdQcmludCcsXG4gICdkdW1wJyxcbiAgJ2ZhdGFsRXJyb3InLFxuICAnZ2V0VmFMaXN0JyxcbiAgJ2lzS25vd25VbmlxdWVseVJlZmVyZW5jZWQnLFxuICAnbWF4JyxcbiAgJ21pbicsXG4gICdudW1lcmljQ2FzdCcsXG4gICdwb2ludHdpc2VNYXgnLFxuICAncG9pbnR3aXNlTWluJyxcbiAgJ3ByZWNvbmRpdGlvbicsXG4gICdwcmVjb25kaXRpb25GYWlsdXJlJyxcbiAgJ3ByaW50JyxcbiAgJ3JlYWRMaW5lJyxcbiAgJ3JlcGVhdEVsZW1lbnQnLFxuICAnc2VxdWVuY2UnLFxuICAnc3RyaWRlJyxcbiAgJ3N3YXAnLFxuICAnc3dpZnRfdW5ib3hGcm9tU3dpZnRWYWx1ZVdpdGhUeXBlJyxcbiAgJ3RyYW5zY29kZScsXG4gICd0eXBlJyxcbiAgJ3Vuc2FmZUJpdENhc3QnLFxuICAndW5zYWZlRG93bmNhc3QnLFxuICAnd2l0aEV4dGVuZGVkTGlmZXRpbWUnLFxuICAnd2l0aFVuc2FmZU11dGFibGVQb2ludGVyJyxcbiAgJ3dpdGhVbnNhZmVQb2ludGVyJyxcbiAgJ3dpdGhWYUxpc3QnLFxuICAnd2l0aG91dEFjdHVhbGx5RXNjYXBpbmcnLFxuICAnemlwJ1xuXTtcblxuLy8gVmFsaWQgZmlyc3QgY2hhcmFjdGVycyBmb3Igb3BlcmF0b3JzLlxuY29uc3Qgb3BlcmF0b3JIZWFkID0gZWl0aGVyKFxuICAvWy89XFwtKyEqJTw+Jnxefj9dLyxcbiAgL1tcXHUwMEExLVxcdTAwQTddLyxcbiAgL1tcXHUwMEE5XFx1MDBBQl0vLFxuICAvW1xcdTAwQUNcXHUwMEFFXS8sXG4gIC9bXFx1MDBCMFxcdTAwQjFdLyxcbiAgL1tcXHUwMEI2XFx1MDBCQlxcdTAwQkZcXHUwMEQ3XFx1MDBGN10vLFxuICAvW1xcdTIwMTYtXFx1MjAxN10vLFxuICAvW1xcdTIwMjAtXFx1MjAyN10vLFxuICAvW1xcdTIwMzAtXFx1MjAzRV0vLFxuICAvW1xcdTIwNDEtXFx1MjA1M10vLFxuICAvW1xcdTIwNTUtXFx1MjA1RV0vLFxuICAvW1xcdTIxOTAtXFx1MjNGRl0vLFxuICAvW1xcdTI1MDAtXFx1Mjc3NV0vLFxuICAvW1xcdTI3OTQtXFx1MkJGRl0vLFxuICAvW1xcdTJFMDAtXFx1MkU3Rl0vLFxuICAvW1xcdTMwMDEtXFx1MzAwM10vLFxuICAvW1xcdTMwMDgtXFx1MzAyMF0vLFxuICAvW1xcdTMwMzBdL1xuKTtcblxuLy8gVmFsaWQgY2hhcmFjdGVycyBmb3Igb3BlcmF0b3JzLlxuY29uc3Qgb3BlcmF0b3JDaGFyYWN0ZXIgPSBlaXRoZXIoXG4gIG9wZXJhdG9ySGVhZCxcbiAgL1tcXHUwMzAwLVxcdTAzNkZdLyxcbiAgL1tcXHUxREMwLVxcdTFERkZdLyxcbiAgL1tcXHUyMEQwLVxcdTIwRkZdLyxcbiAgL1tcXHVGRTAwLVxcdUZFMEZdLyxcbiAgL1tcXHVGRTIwLVxcdUZFMkZdL1xuICAvLyBUT0RPOiBUaGUgZm9sbG93aW5nIGNoYXJhY3RlcnMgYXJlIGFsc28gYWxsb3dlZCwgYnV0IHRoZSByZWdleCBpc24ndCBzdXBwb3J0ZWQgeWV0LlxuICAvLyAvW1xcdXtFMDEwMH0tXFx1e0UwMUVGfV0vdVxuKTtcblxuLy8gVmFsaWQgb3BlcmF0b3IuXG5jb25zdCBvcGVyYXRvciA9IGNvbmNhdChvcGVyYXRvckhlYWQsIG9wZXJhdG9yQ2hhcmFjdGVyLCAnKicpO1xuXG4vLyBWYWxpZCBmaXJzdCBjaGFyYWN0ZXJzIGZvciBpZGVudGlmaWVycy5cbmNvbnN0IGlkZW50aWZpZXJIZWFkID0gZWl0aGVyKFxuICAvW2EtekEtWl9dLyxcbiAgL1tcXHUwMEE4XFx1MDBBQVxcdTAwQURcXHUwMEFGXFx1MDBCMi1cXHUwMEI1XFx1MDBCNy1cXHUwMEJBXS8sXG4gIC9bXFx1MDBCQy1cXHUwMEJFXFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMEZGXS8sXG4gIC9bXFx1MDEwMC1cXHUwMkZGXFx1MDM3MC1cXHUxNjdGXFx1MTY4MS1cXHUxODBEXFx1MTgwRi1cXHUxREJGXS8sXG4gIC9bXFx1MUUwMC1cXHUxRkZGXS8sXG4gIC9bXFx1MjAwQi1cXHUyMDBEXFx1MjAyQS1cXHUyMDJFXFx1MjAzRi1cXHUyMDQwXFx1MjA1NFxcdTIwNjAtXFx1MjA2Rl0vLFxuICAvW1xcdTIwNzAtXFx1MjBDRlxcdTIxMDAtXFx1MjE4RlxcdTI0NjAtXFx1MjRGRlxcdTI3NzYtXFx1Mjc5M10vLFxuICAvW1xcdTJDMDAtXFx1MkRGRlxcdTJFODAtXFx1MkZGRl0vLFxuICAvW1xcdTMwMDQtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzRlxcdTMwNDAtXFx1RDdGRl0vLFxuICAvW1xcdUY5MDAtXFx1RkQzRFxcdUZENDAtXFx1RkRDRlxcdUZERjAtXFx1RkUxRlxcdUZFMzAtXFx1RkU0NF0vLFxuICAvW1xcdUZFNDctXFx1RkZGRF0vXG4gIC8vIFRoZSBmb2xsb3dpbmcgY2hhcmFjdGVycyBhcmUgYWxzbyBhbGxvd2VkLCBidXQgdGhlIHJlZ2V4ZXMgYXJlbid0IHN1cHBvcnRlZCB5ZXQuXG4gIC8vIC9bXFx1ezEwMDAwfS1cXHV7MUZGRkR9XFx1ezIwMDAwLVxcdXsyRkZGRH1cXHV7MzAwMDB9LVxcdXszRkZGRH1cXHV7NDAwMDB9LVxcdXs0RkZGRH1dL3UsXG4gIC8vIC9bXFx1ezUwMDAwfS1cXHV7NUZGRkR9XFx1ezYwMDAwLVxcdXs2RkZGRH1cXHV7NzAwMDB9LVxcdXs3RkZGRH1cXHV7ODAwMDB9LVxcdXs4RkZGRH1dL3UsXG4gIC8vIC9bXFx1ezkwMDAwfS1cXHV7OUZGRkR9XFx1e0EwMDAwLVxcdXtBRkZGRH1cXHV7QjAwMDB9LVxcdXtCRkZGRH1cXHV7QzAwMDB9LVxcdXtDRkZGRH1dL3UsXG4gIC8vIC9bXFx1e0QwMDAwfS1cXHV7REZGRkR9XFx1e0UwMDAwLVxcdXtFRkZGRH1dL3Vcbik7XG5cbi8vIFZhbGlkIGNoYXJhY3RlcnMgZm9yIGlkZW50aWZpZXJzLlxuY29uc3QgaWRlbnRpZmllckNoYXJhY3RlciA9IGVpdGhlcihcbiAgaWRlbnRpZmllckhlYWQsXG4gIC9cXGQvLFxuICAvW1xcdTAzMDAtXFx1MDM2RlxcdTFEQzAtXFx1MURGRlxcdTIwRDAtXFx1MjBGRlxcdUZFMjAtXFx1RkUyRl0vXG4pO1xuXG4vLyBWYWxpZCBpZGVudGlmaWVyLlxuY29uc3QgaWRlbnRpZmllciA9IGNvbmNhdChpZGVudGlmaWVySGVhZCwgaWRlbnRpZmllckNoYXJhY3RlciwgJyonKTtcblxuLy8gVmFsaWQgdHlwZSBpZGVudGlmaWVyLlxuY29uc3QgdHlwZUlkZW50aWZpZXIgPSBjb25jYXQoL1tBLVpdLywgaWRlbnRpZmllckNoYXJhY3RlciwgJyonKTtcblxuLy8gQnVpbHQtaW4gYXR0cmlidXRlcywgd2hpY2ggYXJlIGhpZ2hsaWdodGVkIGFzIGtleXdvcmRzLlxuLy8gQGF2YWlsYWJsZSBpcyBoYW5kbGVkIHNlcGFyYXRlbHkuXG5jb25zdCBrZXl3b3JkQXR0cmlidXRlcyA9IFtcbiAgJ2F1dG9jbG9zdXJlJyxcbiAgY29uY2F0KC9jb252ZW50aW9uXFwoLywgZWl0aGVyKCdzd2lmdCcsICdibG9jaycsICdjJyksIC9cXCkvKSxcbiAgJ2Rpc2NhcmRhYmxlUmVzdWx0JyxcbiAgJ2R5bmFtaWNDYWxsYWJsZScsXG4gICdkeW5hbWljTWVtYmVyTG9va3VwJyxcbiAgJ2VzY2FwaW5nJyxcbiAgJ2Zyb3plbicsXG4gICdHS0luc3BlY3RhYmxlJyxcbiAgJ0lCQWN0aW9uJyxcbiAgJ0lCRGVzaWduYWJsZScsXG4gICdJQkluc3BlY3RhYmxlJyxcbiAgJ0lCT3V0bGV0JyxcbiAgJ0lCU2VndWVBY3Rpb24nLFxuICAnaW5saW5hYmxlJyxcbiAgJ21haW4nLFxuICAnbm9ub2JqYycsXG4gICdOU0FwcGxpY2F0aW9uTWFpbicsXG4gICdOU0NvcHlpbmcnLFxuICAnTlNNYW5hZ2VkJyxcbiAgY29uY2F0KC9vYmpjXFwoLywgaWRlbnRpZmllciwgL1xcKS8pLFxuICAnb2JqYycsXG4gICdvYmpjTWVtYmVycycsXG4gICdwcm9wZXJ0eVdyYXBwZXInLFxuICAncmVxdWlyZXNfc3RvcmVkX3Byb3BlcnR5X2luaXRzJyxcbiAgJ3Rlc3RhYmxlJyxcbiAgJ1VJQXBwbGljYXRpb25NYWluJyxcbiAgJ3Vua25vd24nLFxuICAndXNhYmxlRnJvbUlubGluZSdcbl07XG5cbi8vIENvbnRleHR1YWwga2V5d29yZHMgdXNlZCBpbiBAYXZhaWxhYmxlIGFuZCAjYXZhaWxhYmxlLlxuY29uc3QgYXZhaWxhYmlsaXR5S2V5d29yZHMgPSBbXG4gICdpT1MnLFxuICAnaU9TQXBwbGljYXRpb25FeHRlbnNpb24nLFxuICAnbWFjT1MnLFxuICAnbWFjT1NBcHBsaWNhdGlvbkV4dGVuc2lvbicsXG4gICdtYWNDYXRhbHlzdCcsXG4gICdtYWNDYXRhbHlzdEFwcGxpY2F0aW9uRXh0ZW5zaW9uJyxcbiAgJ3dhdGNoT1MnLFxuICAnd2F0Y2hPU0FwcGxpY2F0aW9uRXh0ZW5zaW9uJyxcbiAgJ3R2T1MnLFxuICAndHZPU0FwcGxpY2F0aW9uRXh0ZW5zaW9uJyxcbiAgJ3N3aWZ0J1xuXTtcblxuLypcbkxhbmd1YWdlOiBTd2lmdFxuRGVzY3JpcHRpb246IFN3aWZ0IGlzIGEgZ2VuZXJhbC1wdXJwb3NlIHByb2dyYW1taW5nIGxhbmd1YWdlIGJ1aWx0IHVzaW5nIGEgbW9kZXJuIGFwcHJvYWNoIHRvIHNhZmV0eSwgcGVyZm9ybWFuY2UsIGFuZCBzb2Z0d2FyZSBkZXNpZ24gcGF0dGVybnMuXG5BdXRob3I6IFN0ZXZlbiBWYW4gSW1wZSA8c3RldmVuLnZhbmltcGVAaWNsb3VkLmNvbT5cbkNvbnRyaWJ1dG9yczogQ2hyaXMgRWlkaG9mIDxjaHJpc0BlaWRob2Yubmw+LCBOYXRlIENvb2sgPG5hdGVjb29rQGdtYWlsLmNvbT4sIEFsZXhhbmRlciBMaWNodGVyIDxtYW5uaUxAZ214Lm5ldD4sIFJpY2hhcmQgR2lic29uIDxnaWJzb24wNDJAZ2l0aHViPlxuV2Vic2l0ZTogaHR0cHM6Ly9zd2lmdC5vcmdcbkNhdGVnb3J5OiBjb21tb24sIHN5c3RlbVxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIHN3aWZ0KGhsanMpIHtcbiAgLy8gaHR0cHM6Ly9kb2NzLnN3aWZ0Lm9yZy9zd2lmdC1ib29rL1JlZmVyZW5jZU1hbnVhbC9MZXhpY2FsU3RydWN0dXJlLmh0bWwjSUQ0MTFcbiAgY29uc3QgQkxPQ0tfQ09NTUVOVCA9IGhsanMuQ09NTUVOVChcbiAgICAnL1xcXFwqJyxcbiAgICAnXFxcXCovJyxcbiAgICB7XG4gICAgICBjb250YWluczogWyAnc2VsZicgXVxuICAgIH1cbiAgKTtcblxuICAvLyBodHRwczovL2RvY3Muc3dpZnQub3JnL3N3aWZ0LWJvb2svUmVmZXJlbmNlTWFudWFsL0xleGljYWxTdHJ1Y3R1cmUuaHRtbCNJRDQxM1xuICAvLyBodHRwczovL2RvY3Muc3dpZnQub3JnL3N3aWZ0LWJvb2svUmVmZXJlbmNlTWFudWFsL3p6U3VtbWFyeU9mVGhlR3JhbW1hci5odG1sXG4gIGNvbnN0IERPVF9LRVlXT1JEID0ge1xuICAgIGNsYXNzTmFtZTogJ2tleXdvcmQnLFxuICAgIGJlZ2luOiBjb25jYXQoL1xcLi8sIGxvb2thaGVhZChlaXRoZXIoLi4uZG90S2V5d29yZHMsIC4uLm9wdGlvbmFsRG90S2V5d29yZHMpKSksXG4gICAgZW5kOiBlaXRoZXIoLi4uZG90S2V5d29yZHMsIC4uLm9wdGlvbmFsRG90S2V5d29yZHMpLFxuICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZVxuICB9O1xuICBjb25zdCBLRVlXT1JEX0dVQVJEID0ge1xuICAgIC8vIENvbnN1bWUgLmtleXdvcmQgdG8gcHJldmVudCBoaWdobGlnaHRpbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBhcyBrZXl3b3Jkcy5cbiAgICBiZWdpbjogY29uY2F0KC9cXC4vLCBlaXRoZXIoLi4ua2V5d29yZHMpKSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcbiAgY29uc3QgUExBSU5fS0VZV09SRFMgPSBrZXl3b3Jkc1xuICAgIC5maWx0ZXIoa3cgPT4gdHlwZW9mIGt3ID09PSAnc3RyaW5nJylcbiAgICAuY29uY2F0KFsgXCJffDBcIiBdKTsgLy8gc2VlbXMgY29tbW9uLCBzbyAwIHJlbGV2YW5jZVxuICBjb25zdCBSRUdFWF9LRVlXT1JEUyA9IGtleXdvcmRzXG4gICAgLmZpbHRlcihrdyA9PiB0eXBlb2Yga3cgIT09ICdzdHJpbmcnKSAvLyBmaW5kIHJlZ2V4XG4gICAgLmNvbmNhdChrZXl3b3JkVHlwZXMpXG4gICAgLm1hcChrZXl3b3JkV3JhcHBlcik7XG4gIGNvbnN0IEtFWVdPUkQgPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAna2V5d29yZCcsXG4gICAgICAgIGJlZ2luOiBlaXRoZXIoLi4uUkVHRVhfS0VZV09SRFMsIC4uLm9wdGlvbmFsRG90S2V5d29yZHMpXG4gICAgICB9XG4gICAgXVxuICB9O1xuICAvLyBmaW5kIGFsbCB0aGUgcmVndWxhciBrZXl3b3Jkc1xuICBjb25zdCBLRVlXT1JEUyA9IHtcbiAgICAkcGF0dGVybjogZWl0aGVyKFxuICAgICAgL1xcYlxcdysoXFwoXFx3K1xcKSk/LywgLy8ga3cgb3Iga3coYXJnKVxuICAgICAgLyNcXHcrLyAvLyBudW1iZXIga2V5d29yZHNcbiAgICApLFxuICAgIGtleXdvcmQ6IFBMQUlOX0tFWVdPUkRTXG4gICAgICAuY29uY2F0KG51bWJlclNpZ25LZXl3b3JkcylcbiAgICAgIC5qb2luKFwiIFwiKSxcbiAgICBsaXRlcmFsOiBsaXRlcmFscy5qb2luKFwiIFwiKVxuICB9O1xuICBjb25zdCBLRVlXT1JEX01PREVTID0gW1xuICAgIERPVF9LRVlXT1JELFxuICAgIEtFWVdPUkRfR1VBUkQsXG4gICAgS0VZV09SRFxuICBdO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBsZS9zd2lmdC90cmVlL21haW4vc3RkbGliL3B1YmxpYy9jb3JlXG4gIGNvbnN0IEJVSUxUX0lOX0dVQVJEID0ge1xuICAgIC8vIENvbnN1bWUgLmJ1aWx0X2luIHRvIHByZXZlbnQgaGlnaGxpZ2h0aW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgYmVnaW46IGNvbmNhdCgvXFwuLywgZWl0aGVyKC4uLmJ1aWx0SW5zKSksXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGNvbnN0IEJVSUxUX0lOID0ge1xuICAgIGNsYXNzTmFtZTogJ2J1aWx0X2luJyxcbiAgICBiZWdpbjogY29uY2F0KC9cXGIvLCBlaXRoZXIoLi4uYnVpbHRJbnMpLCAvKD89XFwoKS8pXG4gIH07XG4gIGNvbnN0IEJVSUxUX0lOUyA9IFtcbiAgICBCVUlMVF9JTl9HVUFSRCxcbiAgICBCVUlMVF9JTlxuICBdO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9SZWZlcmVuY2VNYW51YWwvTGV4aWNhbFN0cnVjdHVyZS5odG1sI0lENDE4XG4gIGNvbnN0IE9QRVJBVE9SX0dVQVJEID0ge1xuICAgIC8vIFByZXZlbnQgLT4gZnJvbSBiZWluZyBoaWdobGlnaHRpbmcgYXMgYW4gb3BlcmF0b3IuXG4gICAgYmVnaW46IC8tPi8sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG4gIGNvbnN0IE9QRVJBVE9SID0ge1xuICAgIGNsYXNzTmFtZTogJ29wZXJhdG9yJyxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IG9wZXJhdG9yXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBkb3Qtb3BlcmF0b3I6IG9ubHkgb3BlcmF0b3JzIHRoYXQgc3RhcnQgd2l0aCBhIGRvdCBhcmUgYWxsb3dlZCB0byB1c2UgZG90cyBhc1xuICAgICAgICAvLyBjaGFyYWN0ZXJzICguLi4sIC4uLjwsIC4qLCBldGMpLiBTbyB0aGVyZSBydWxlIGhlcmUgaXM6IGEgZG90IGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgdGhhdCBtYXkgYWxzbyBpbmNsdWRlIGRvdHMuXG4gICAgICAgIGJlZ2luOiBgXFxcXC4oXFxcXC58JHtvcGVyYXRvckNoYXJhY3Rlcn0pK2BcbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGNvbnN0IE9QRVJBVE9SUyA9IFtcbiAgICBPUEVSQVRPUl9HVUFSRCxcbiAgICBPUEVSQVRPUlxuICBdO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9SZWZlcmVuY2VNYW51YWwvTGV4aWNhbFN0cnVjdHVyZS5odG1sI2dyYW1tYXJfbnVtZXJpYy1saXRlcmFsXG4gIC8vIFRPRE86IFVwZGF0ZSBmb3IgbGVhZGluZyBgLWAgYWZ0ZXIgbG9va2JlaGluZCBpcyBzdXBwb3J0ZWQgZXZlcnl3aGVyZVxuICBjb25zdCBkZWNpbWFsRGlnaXRzID0gJyhbMC05XV8qKSsnO1xuICBjb25zdCBoZXhEaWdpdHMgPSAnKFswLTlhLWZBLUZdXyopKyc7XG4gIGNvbnN0IE5VTUJFUiA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICB2YXJpYW50czogW1xuICAgICAgLy8gZGVjaW1hbCBmbG9hdGluZy1wb2ludC1saXRlcmFsIChzdWJzdW1lcyBkZWNpbWFsLWxpdGVyYWwpXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiBgXFxcXGIoJHtkZWNpbWFsRGlnaXRzfSkoXFxcXC4oJHtkZWNpbWFsRGlnaXRzfSkpP2AgKyBgKFtlRV1bKy1dPygke2RlY2ltYWxEaWdpdHN9KSk/XFxcXGJgXG4gICAgICB9LFxuICAgICAgLy8gaGV4YWRlY2ltYWwgZmxvYXRpbmctcG9pbnQtbGl0ZXJhbCAoc3Vic3VtZXMgaGV4YWRlY2ltYWwtbGl0ZXJhbClcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IGBcXFxcYjB4KCR7aGV4RGlnaXRzfSkoXFxcXC4oJHtoZXhEaWdpdHN9KSk/YCArIGAoW3BQXVsrLV0/KCR7ZGVjaW1hbERpZ2l0c30pKT9cXFxcYmBcbiAgICAgIH0sXG4gICAgICAvLyBvY3RhbC1saXRlcmFsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxiMG8oWzAtN11fKikrXFxiL1xuICAgICAgfSxcbiAgICAgIC8vIGJpbmFyeS1saXRlcmFsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFxiMGIoWzAxXV8qKStcXGIvXG4gICAgICB9XG4gICAgXVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9SZWZlcmVuY2VNYW51YWwvTGV4aWNhbFN0cnVjdHVyZS5odG1sI2dyYW1tYXJfc3RyaW5nLWxpdGVyYWxcbiAgY29uc3QgRVNDQVBFRF9DSEFSQUNURVIgPSAocmF3RGVsaW1pdGVyID0gXCJcIikgPT4gKHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IGNvbmNhdCgvXFxcXC8sIHJhd0RlbGltaXRlciwgL1swXFxcXHRuclwiJ10vKVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IGNvbmNhdCgvXFxcXC8sIHJhd0RlbGltaXRlciwgL3VcXHtbMC05YS1mQS1GXXsxLDh9XFx9LylcbiAgICAgIH1cbiAgICBdXG4gIH0pO1xuICBjb25zdCBFU0NBUEVEX05FV0xJTkUgPSAocmF3RGVsaW1pdGVyID0gXCJcIikgPT4gKHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46IGNvbmNhdCgvXFxcXC8sIHJhd0RlbGltaXRlciwgL1tcXHQgXSooPzpbXFxyXFxuXXxcXHJcXG4pLylcbiAgfSk7XG4gIGNvbnN0IElOVEVSUE9MQVRJT04gPSAocmF3RGVsaW1pdGVyID0gXCJcIikgPT4gKHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgbGFiZWw6IFwiaW50ZXJwb2xcIixcbiAgICBiZWdpbjogY29uY2F0KC9cXFxcLywgcmF3RGVsaW1pdGVyLCAvXFwoLyksXG4gICAgZW5kOiAvXFwpL1xuICB9KTtcbiAgY29uc3QgTVVMVElMSU5FX1NUUklORyA9IChyYXdEZWxpbWl0ZXIgPSBcIlwiKSA9PiAoe1xuICAgIGJlZ2luOiBjb25jYXQocmF3RGVsaW1pdGVyLCAvXCJcIlwiLyksXG4gICAgZW5kOiBjb25jYXQoL1wiXCJcIi8sIHJhd0RlbGltaXRlciksXG4gICAgY29udGFpbnM6IFtcbiAgICAgIEVTQ0FQRURfQ0hBUkFDVEVSKHJhd0RlbGltaXRlciksXG4gICAgICBFU0NBUEVEX05FV0xJTkUocmF3RGVsaW1pdGVyKSxcbiAgICAgIElOVEVSUE9MQVRJT04ocmF3RGVsaW1pdGVyKVxuICAgIF1cbiAgfSk7XG4gIGNvbnN0IFNJTkdMRV9MSU5FX1NUUklORyA9IChyYXdEZWxpbWl0ZXIgPSBcIlwiKSA9PiAoe1xuICAgIGJlZ2luOiBjb25jYXQocmF3RGVsaW1pdGVyLCAvXCIvKSxcbiAgICBlbmQ6IGNvbmNhdCgvXCIvLCByYXdEZWxpbWl0ZXIpLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBFU0NBUEVEX0NIQVJBQ1RFUihyYXdEZWxpbWl0ZXIpLFxuICAgICAgSU5URVJQT0xBVElPTihyYXdEZWxpbWl0ZXIpXG4gICAgXVxuICB9KTtcbiAgY29uc3QgU1RSSU5HID0ge1xuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIE1VTFRJTElORV9TVFJJTkcoKSxcbiAgICAgIE1VTFRJTElORV9TVFJJTkcoXCIjXCIpLFxuICAgICAgTVVMVElMSU5FX1NUUklORyhcIiMjXCIpLFxuICAgICAgTVVMVElMSU5FX1NUUklORyhcIiMjI1wiKSxcbiAgICAgIFNJTkdMRV9MSU5FX1NUUklORygpLFxuICAgICAgU0lOR0xFX0xJTkVfU1RSSU5HKFwiI1wiKSxcbiAgICAgIFNJTkdMRV9MSU5FX1NUUklORyhcIiMjXCIpLFxuICAgICAgU0lOR0xFX0xJTkVfU1RSSU5HKFwiIyMjXCIpXG4gICAgXVxuICB9O1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9SZWZlcmVuY2VNYW51YWwvTGV4aWNhbFN0cnVjdHVyZS5odG1sI0lENDEyXG4gIGNvbnN0IFFVT1RFRF9JREVOVElGSUVSID0ge1xuICAgIGJlZ2luOiBjb25jYXQoL2AvLCBpZGVudGlmaWVyLCAvYC8pXG4gIH07XG4gIGNvbnN0IElNUExJQ0lUX1BBUkFNRVRFUiA9IHtcbiAgICBjbGFzc05hbWU6ICd2YXJpYWJsZScsXG4gICAgYmVnaW46IC9cXCRcXGQrL1xuICB9O1xuICBjb25zdCBQUk9QRVJUWV9XUkFQUEVSX1BST0pFQ1RJT04gPSB7XG4gICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgIGJlZ2luOiBgXFxcXCQke2lkZW50aWZpZXJDaGFyYWN0ZXJ9K2BcbiAgfTtcbiAgY29uc3QgSURFTlRJRklFUlMgPSBbXG4gICAgUVVPVEVEX0lERU5USUZJRVIsXG4gICAgSU1QTElDSVRfUEFSQU1FVEVSLFxuICAgIFBST1BFUlRZX1dSQVBQRVJfUFJPSkVDVElPTlxuICBdO1xuXG4gIC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9SZWZlcmVuY2VNYW51YWwvQXR0cmlidXRlcy5odG1sXG4gIGNvbnN0IEFWQUlMQUJMRV9BVFRSSUJVVEUgPSB7XG4gICAgYmVnaW46IC8oQHwjKWF2YWlsYWJsZVxcKC8sXG4gICAgZW5kOiAvXFwpLyxcbiAgICBrZXl3b3Jkczoge1xuICAgICAgJHBhdHRlcm46IC9bQCNdP1xcdysvLFxuICAgICAga2V5d29yZDogYXZhaWxhYmlsaXR5S2V5d29yZHNcbiAgICAgICAgLmNvbmNhdChbXG4gICAgICAgICAgXCJAYXZhaWxhYmxlXCIsXG4gICAgICAgICAgXCIjYXZhaWxhYmxlXCJcbiAgICAgICAgXSlcbiAgICAgICAgLmpvaW4oJyAnKVxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIC4uLk9QRVJBVE9SUyxcbiAgICAgIE5VTUJFUixcbiAgICAgIFNUUklOR1xuICAgIF1cbiAgfTtcbiAgY29uc3QgS0VZV09SRF9BVFRSSUJVVEUgPSB7XG4gICAgY2xhc3NOYW1lOiAna2V5d29yZCcsXG4gICAgYmVnaW46IGNvbmNhdCgvQC8sIGVpdGhlciguLi5rZXl3b3JkQXR0cmlidXRlcykpXG4gIH07XG4gIGNvbnN0IFVTRVJfREVGSU5FRF9BVFRSSUJVVEUgPSB7XG4gICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgYmVnaW46IGNvbmNhdCgvQC8sIGlkZW50aWZpZXIpXG4gIH07XG4gIGNvbnN0IEFUVFJJQlVURVMgPSBbXG4gICAgQVZBSUxBQkxFX0FUVFJJQlVURSxcbiAgICBLRVlXT1JEX0FUVFJJQlVURSxcbiAgICBVU0VSX0RFRklORURfQVRUUklCVVRFXG4gIF07XG5cbiAgLy8gaHR0cHM6Ly9kb2NzLnN3aWZ0Lm9yZy9zd2lmdC1ib29rL1JlZmVyZW5jZU1hbnVhbC9UeXBlcy5odG1sXG4gIGNvbnN0IFRZUEUgPSB7XG4gICAgYmVnaW46IGxvb2thaGVhZCgvXFxiW0EtWl0vKSxcbiAgICByZWxldmFuY2U6IDAsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgLy8gQ29tbW9uIEFwcGxlIGZyYW1ld29ya3MsIGZvciByZWxldmFuY2UgYm9vc3RcbiAgICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICAgIGJlZ2luOiBjb25jYXQoLyhBVnxDQXxDRnxDR3xDSXxDTHxDTXxDTnxDVHxNS3xNUHxNVEt8TVRMfE5TfFNDTnxTS3xVSXxXS3xYQykvLCBpZGVudGlmaWVyQ2hhcmFjdGVyLCAnKycpXG4gICAgICB9LFxuICAgICAgeyAvLyBUeXBlIGlkZW50aWZpZXJcbiAgICAgICAgY2xhc3NOYW1lOiAndHlwZScsXG4gICAgICAgIGJlZ2luOiB0eXBlSWRlbnRpZmllcixcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgeyAvLyBPcHRpb25hbCB0eXBlXG4gICAgICAgIGJlZ2luOiAvWz8hXSsvLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7IC8vIFZhcmlhZGljIHBhcmFtZXRlclxuICAgICAgICBiZWdpbjogL1xcLlxcLlxcLi8sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHsgLy8gUHJvdG9jb2wgY29tcG9zaXRpb25cbiAgICAgICAgYmVnaW46IGNvbmNhdCgvXFxzKyZcXHMrLywgbG9va2FoZWFkKHR5cGVJZGVudGlmaWVyKSksXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgY29uc3QgR0VORVJJQ19BUkdVTUVOVFMgPSB7XG4gICAgYmVnaW46IC88LyxcbiAgICBlbmQ6IC8+LyxcbiAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIC4uLktFWVdPUkRfTU9ERVMsXG4gICAgICAuLi5BVFRSSUJVVEVTLFxuICAgICAgT1BFUkFUT1JfR1VBUkQsXG4gICAgICBUWVBFXG4gICAgXVxuICB9O1xuICBUWVBFLmNvbnRhaW5zLnB1c2goR0VORVJJQ19BUkdVTUVOVFMpO1xuXG4gIC8vIEFkZCBzdXBwb3J0ZWQgc3VibW9kZXMgdG8gc3RyaW5nIGludGVycG9sYXRpb24uXG4gIGZvciAoY29uc3QgdmFyaWFudCBvZiBTVFJJTkcudmFyaWFudHMpIHtcbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gdmFyaWFudC5jb250YWlucy5maW5kKG1vZGUgPT4gbW9kZS5sYWJlbCA9PT0gXCJpbnRlcnBvbFwiKTtcbiAgICAvLyBUT0RPOiBJbnRlcnBvbGF0aW9uIGNhbiBjb250YWluIGFueSBleHByZXNzaW9uLCBzbyB0aGVyZSdzIHJvb20gZm9yIGltcHJvdmVtZW50IGhlcmUuXG4gICAgaW50ZXJwb2xhdGlvbi5rZXl3b3JkcyA9IEtFWVdPUkRTO1xuICAgIGNvbnN0IHN1Ym1vZGVzID0gW1xuICAgICAgLi4uS0VZV09SRF9NT0RFUyxcbiAgICAgIC4uLkJVSUxUX0lOUyxcbiAgICAgIC4uLk9QRVJBVE9SUyxcbiAgICAgIE5VTUJFUixcbiAgICAgIFNUUklORyxcbiAgICAgIC4uLklERU5USUZJRVJTXG4gICAgXTtcbiAgICBpbnRlcnBvbGF0aW9uLmNvbnRhaW5zID0gW1xuICAgICAgLi4uc3VibW9kZXMsXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgICAgZW5kOiAvXFwpLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAnc2VsZicsXG4gICAgICAgICAgLi4uc3VibW9kZXNcbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTd2lmdCcsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBCTE9DS19DT01NRU5ULFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdmdW5jJyxcbiAgICAgICAgZW5kOiAvXFx7LyxcbiAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7XG4gICAgICAgICAgICBiZWdpbjogL1tBLVphLXokX11bMC05QS1aYS16JF9dKi9cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogLzwvLFxuICAgICAgICAgICAgZW5kOiAvPi9cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAgZW5kc1BhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgICdzZWxmJyxcbiAgICAgICAgICAgICAgLi4uS0VZV09SRF9NT0RFUyxcbiAgICAgICAgICAgICAgTlVNQkVSLFxuICAgICAgICAgICAgICBTVFJJTkcsXG4gICAgICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgICAgIHsgLy8gcmVsZXZhbmNlIGJvb3N0ZXJcbiAgICAgICAgICAgICAgICBiZWdpbjogJzonXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbGxlZ2FsOiAvW1wiJ10vXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBpbGxlZ2FsOiAvXFxbfCUvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdzdHJ1Y3QgcHJvdG9jb2wgY2xhc3MgZXh0ZW5zaW9uIGVudW0nLFxuICAgICAgICBlbmQ6ICdcXFxceycsXG4gICAgICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLmluaGVyaXQoaGxqcy5USVRMRV9NT0RFLCB7XG4gICAgICAgICAgICBiZWdpbjogL1tBLVphLXokX11bXFx1MDBDMC1cXHUwMkI4MC05QS1aYS16JF9dKi9cbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi5LRVlXT1JEX01PREVTXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdpbXBvcnQnLFxuICAgICAgICBlbmQ6IC8kLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgQkxPQ0tfQ09NTUVOVFxuICAgICAgICBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICAuLi5LRVlXT1JEX01PREVTLFxuICAgICAgLi4uQlVJTFRfSU5TLFxuICAgICAgLi4uT1BFUkFUT1JTLFxuICAgICAgTlVNQkVSLFxuICAgICAgU1RSSU5HLFxuICAgICAgLi4uSURFTlRJRklFUlMsXG4gICAgICAuLi5BVFRSSUJVVEVTLFxuICAgICAgVFlQRVxuICAgIF1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzd2lmdDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/highlight.js/lib/languages/swift.js\n");

/***/ })

}]);